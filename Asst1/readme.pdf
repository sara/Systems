hing out pseuodocode for the Systems Programming Asst1:

unique in that we will be using the fact that the malloc-able space is only 5000 bytes
to store data relatively, using 2 bytes of metadata of the (short*) format to indicate
length of contiguous memory as well as a free/used bit to determine how free() calls are handled

challenges:
0. will ptrs point to metadata, or to actual data? need to standardize representation
1. how to handle mallocing without enough space at position
2. defraging accurately, losslessly

malloc(int i):

NOTES: this implementation can only malloc even amounts of memory

	0. make tmp ptr to start of array // point to metadata or user data????
		//i think that this should point to metadata and then return a ptr to userdata (through+2)
	1. check to see if metadata val is free (even)
		a. if so, check to see if there's enough space to insert the given size of data
**			a. if so, insert in place (SEE INSERT COMMAND)
**			a. if not, defrag or go to next free metadata, or throw error ?!?!?			
		b. else, not free, increment pointer to next chunck of metadata (ptr +=  metadata val - (val%2))
	2. return ptr to userdata



insert(ptr p, int i):

	0. starting at location of free, large metadata from malloc(), create ptr to right after metadata
	1. make another pointer to the location of new metadata block following the given size of data to malloc (i)
	2. set prev metadata to (i+1) to indicate used, and set up parse chain
	3. set new metadata to remaining length of array (prev metadata - i - 2 (for new metadata block))
	4. return ptr to malloced user data


free(ptr p):

	0. make tmp ptr at start of array // point to metadata or user data????
		//pointing to userdata would probably be easier here, for quicker comparisons on while loop
	1. loop while (p != tmp)
		a. add val of metadata (-(val()%2), to jump over both free and used data properly) to tmp
	2. if (p == tmp), check if metadata is odd (data has not been freed)
		a. if odd (not free), then free it by decrementing from metadata
			this will treat it as free, without changing values, or breaking chain
		b. if already free, throw error using preprocessor __FILE__ and __LINE__
	3. if you cant find ptr, then it probably hasnt been malloced (OR WE FUCKED UP!!!)
		a. throw error using preprocessor __FILE__ and __LINE__
	4. Whenever something is freed, check the block to the left and the right of it to see if its also free
		//this is the most effective way to handle defraging mid-stream


defrag():

NOTES:	defrag called whenever malloc cannot find enough space for new info? 

	0. make tmp ptr at start of array 
		// i think this should point to metatdata because we dont care about user data for this
	1. loop through metadata values until you find TWO FREE (even) block in a row
	2. by transitive property, you can add the value of the second one to the first one (+2)
		// need +2 because metadata of second one is no longer necessary
		// this eventually becomes a problem if you free EVERYTHING, master meta gets set to 5000
		// need catch statement for above
	4. go back and try mallocing again
